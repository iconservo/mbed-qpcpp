//****************************************************************************
// Model: blinky.qm
// File:  ./blinky.cpp
//
// This code has been generated by QM tool (see state-machine.com/qm).
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This program is open source software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
// for more details.
//****************************************************************************
//${.::blinky.cpp} ...........................................................
#include "qp_port.h"
#include "blinky.h"
#include "bsp.h"

Q_DEFINE_THIS_FILE



//${AOs::BlinkClass} .........................................................
class BlinkClass : public QP::QActive {
private:
    QP::QTimeEvt m_timeEvt;

public:
    BlinkClass();

protected:
    static QP::QState initial(BlinkClass * const me, QP::QEvt const * const e);
    static QP::QState led_on(BlinkClass * const me, QP::QEvt const * const e);
    static QP::QState led_off(BlinkClass * const me, QP::QEvt const * const e);
};





static BlinkClass l_blinky;

QP::QActive * const AO_Blinky = &l_blinky;




//${AOs::BlinkClass} .........................................................
//${AOs::BlinkClass::BlinkClass} .............................................
BlinkClass::BlinkClass()
  : QActive(Q_STATE_CAST(&BlinkClass::initial)) ,
   m_timeEvt(TIMEOUT_SIG){
}

//${AOs::BlinkClass::SM} .....................................................
QP::QState BlinkClass::initial(BlinkClass * const me, QP::QEvt const * const e) {
    // ${AOs::BlinkClass::SM::initial}
    // Make sure it only happens once
    static bool registered = false;

    // Stop compiler warning
    (void)e;

    // Add objects and signals to the kernal dictionary for QSPY
    if (!registered) {
        registered = true;

        QS_OBJ_DICTIONARY(&l_blinky);
        QS_OBJ_DICTIONARY(&l_blinky.m_timeEvt);

        QS_FUN_DICTIONARY(&BlinkClass::initial);
        QS_FUN_DICTIONARY(&BlinkClass::led_on);
        QS_FUN_DICTIONARY(&BlinkClass::led_off);
    }

    QS_SIG_DICTIONARY(TIMEOUT_SIG, me);
    return Q_TRAN(&led_on);
}
//${AOs::BlinkClass::SM::led_on} .............................................
QP::QState BlinkClass::led_on(BlinkClass * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${AOs::BlinkClass::SM::led_on}
        case Q_ENTRY_SIG: {
            BSP_ledOn();
            me->m_timeEvt.postEvery(me, BSP_TICKS_PER_SEC / 2);
            status_ = Q_HANDLED();
            break;
        }
        // ${AOs::BlinkClass::SM::led_on}
        case Q_EXIT_SIG: {
            (void)me->m_timeEvt.disarm();
            status_ = Q_HANDLED();
            break;
        }
        // ${AOs::BlinkClass::SM::led_on::TIMEOUT}
        case TIMEOUT_SIG: {
            status_ = Q_TRAN(&led_off);
            break;
        }
        default: {
            status_ = Q_SUPER(&QP::QHsm::top);
            break;
        }
    }
    return status_;
}
//${AOs::BlinkClass::SM::led_off} ............................................
QP::QState BlinkClass::led_off(BlinkClass * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${AOs::BlinkClass::SM::led_off}
        case Q_ENTRY_SIG: {
            BSP_ledOff();
            me->m_timeEvt.postEvery(me, BSP_TICKS_PER_SEC / 2);
            status_ = Q_HANDLED();
            break;
        }
        // ${AOs::BlinkClass::SM::led_off}
        case Q_EXIT_SIG: {
            (void)me->m_timeEvt.disarm();
            status_ = Q_HANDLED();
            break;
        }
        // ${AOs::BlinkClass::SM::led_off::TIMEOUT}
        case TIMEOUT_SIG: {
            status_ = Q_TRAN(&led_on);
            break;
        }
        default: {
            status_ = Q_SUPER(&QP::QHsm::top);
            break;
        }
    }
    return status_;
}
